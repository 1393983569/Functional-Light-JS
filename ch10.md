# Functional-Light JavaScript
# Chapter 10: Functional Async

这本书读到这里，你现在拥有了所有 FP —— 我称之为 “轻量函数式编程” —— 基础的原始概念。在这一章中，我们会将这些概念应用于一中不同的环境，但不会出现特别的新想法。

至此，我们做的所有事情几乎都是同步的，也就是说我们使用立即的输入调用函数并立即得到输出值。许多工作可以用这种方式完成，但对于一个现代 JS 应用程序的整体来说根本不够用。为了真正地对 JS的现实世界中的 FP 做好准备，我们需要理解异步 FP。

我们本章的目标是将我们对使用 FP 进行值的管理的思考，扩展至将这样的操作分散到一段时间上。

## Time As State

在你的整个应用程序中最复杂的状态就是时间。也就是说，如果状态在你坚定的控制之下立即地从一种状态转换到另一种，那么状态管理就容易多了。当你应用程序的状态为了响应分散在一段时间上的事件而隐含地变化时，它的管理难度就会呈几何级数增长。

通过使代码更可信与更可预测来使它更易于阅读 —— 我们在这本书中展示 FP 的方式的每一部分都与此有关。当你在程序中引入异步的时候，这些努力将受到很大冲击。

让我们说的更明白一点：一些操作不会同步地完成，就单纯这一点来说不是我们关心的；发起异步行为很容易。需要很多额外努力的是，如何协调这些动作的应答，这些应答中的每一个都会潜在地改变你应用程序的状态。

那么，是你作为作者为此努力好呢？还是将这个问题留给你代码的读者，让他们自己去搞清如果 A 在 B 之前完成（或反之）程序将是什么状态？这是一个夸张的问题，但从我的观点来说它有一个十分坚定地答案：为了使这样复杂的代码更具可读性，作者必须要付出比平常多得多的努力。

### Reducing Time

异步编程最重要的成果之一，是通过将时间从我们的关注范围中抽象出去来简化状态变化管理。

为了展示这一点，我们首先来看一个存在竟合状态（也就是，时间复杂性）而必须手动管理的场景：

```js
var customerId = 42;
var customer;

lookupCustomer( customerId, function onCustomer(customerRecord){
	var orders = customer ? customer.orders : null;
	customer = customerRecord;
	if (orders) {
		customer.orders = orders;
	}
} );

lookupOrders( customerId, function onOrders(customerOrders){
	if (!customer) {
		customer = {};
	}
	customer.orders = customerOrders;
} );
```

回调 `onCustomer(..)` 和 `onOrders(..)` 处于一种二元竟合状态。假定它们同时运行，那么任何一个都有可能首先运行，而预测哪一个将会发射是不可能的。

如果我们可以将 `lookupOrders(..)` 嵌入到 `onCustomer(..)` 内部，我们就可以确保 `onOrders(..)` 在 `onCustomer(..)` 之后运行。但我们不能这么做，因为我们需要这两个查询并发地发生。

那么为了将这种基于时间的状态复杂性规范化，与一个外部词法闭包的变量 `customer` 一起，我们在回调总分别使用了一对 `if` 语句检测。当每个回调运行时，它检查 `customer` 的状态，以此判断它自己的相对顺序；如果对一个回调来说 `customer` 没有设定，那么它就是第一个运行的，否则是第二个。

这段代码好用，但从可读性上看远不理想。事件复杂性使这段代码很难读懂。

让我们使用 JS promise 来把时间抽离出去：

```js
var customerId = 42;

var customerPromise = lookupCustomer( customerId );
var ordersPromise = lookupOrders( customerId );

customerPromise.then( function onCustomer(customer){
	ordersPromise.then( function onOrders(orders){
		customer.orders = orders;
	} );
} );
```

现在回调 `onOrders(..)` 位于回调 `onCustomer(..)` 内部，所以它们的相对顺序得到了保证。查询的并发是通过在指定 `then(..)` 应答处理之前分离地发起 `lookupCustomer(..)` 和 `lookupOrders(..)` 来实现的。

这可能不明显，不过要不是 promise 的行为被定义的方式，这个代码段就会与生俱来地具有竟合状态。如果 `order` 的查询在 `ordersPromise.then(..)` 被调用以提供一个 `onOrders(..)` 回调之前完成，那么 *某些东西* 就需要足够聪明地保持 `orders` 列表，直到 `onOrders(..)` 可以被调用。事实上，当 `record` 在 `onCustomer(..)` 指定要接受它之前出现时，同样的问题也会出现。

那个 *某些东西* 就是我们在前一个代码段中讨论过的同种时间复杂性逻辑。但我们一点都不用担心这种复杂性，不管是编写代码还是 —— 更重要的 —— 阅读代码，因为 promise 为我处理好了那种时间规范化。

一个 promise 以一种时间无关的方式表示一个（未来）值。另外，从一个 promise 总抽取值就是一个立即值同步赋值（通过 `=`）的异步形式。换句话说，一个 promise 将一个 `=` 赋值操作分散到一段时间上，以一种可信（时间无关）的方式。

现在我们将探索如何相似地将本书之前的各种同步 FP 操作分散到一段时间之上。

## Eager vs Lazy

Eager and lazy in the realm of computer science aren't compliments or insults, but rather ways to describe whether an operation will finish right away or progress over time.

The FP operations that we've seen in this text can be characterized as eager because they operate synchronously (right now) on a discrete immediate value or list/structure of values.

Recall:

```js
var a = [1,2,3]

var b = a.map( v => v * 2 );

b;			// [2,4,6]
```

This mapping from `a` to `b` is eager because it operates on all the values in the `a` array at that moment, and produces a new `b` array. If you later modify `a`, for example adding a new value to the end of it, nothing will change about the contents of `b`. That's eager FP.

But what would it look like to have a lazy FP operation? Consider something like this:

```js
var a = [];

var b = mapLazy( a, v => v * 2 );

a.push( 1 );

a[0];		// 1
b[0];		// 2

a.push( 2 );

a[1];		// 2
b[1];		// 4
```

The `mapLazy(..)` we've imagined here essentially "listens" to the `a` array, and every time a new value is added to the end of it (with `push(..)`), it runs the `v => v * 2` mapping function and pushes the transformed value to the `b` array.

**Note:** The implementation of `mapLazy(..)` has not been shown because this is a fictional illustration, not a real operation. To accomplish this kind of lazy operation pairing between `a` and `b`, they will need to be smarter than simple arrays.

Consider the benefits of being able to pair an `a` and `b` together, where any time you put a value into `a`, it's transformed and projected to `b`. That's the same kind of declarative FP power out of a `map(..)` operation, but now it can be stretched over time; you don't have to know all the values of `a` to set up the mapping.

## Reactive FP

To understand how we could create and use a lazy mapping between two sets of values, we need to abstract our idea of list (array) a bit.

Let's imagine a smarter kind of array, not one which simply holds values but one which lazily receives and responds (aka "reacts") to values. Consider:

```js
var a = new LazyArray();

var b = a.map( function double(v){
	return v * 2;
} );

setInterval( function everySecond(){
	a.push( Math.random() );
}, 1000 );
```

So far, this snippet doesn't look any different than a normal array. The only unusual thing is that we're used to the `map(..)` running eagerly and immediately producing a `b` array with all the currently mapped values from `a`. But the timer pushing random values into `a` is strange, since all those values are coming *after* the `map(..)` call.

But this fictional `LazyArray` is different; it assumes that values may come one at a time, over time. Just `push(..)` values in whenever you want. `b` will be a lazy mapping of whatever values eventually end up in `a`.

Also, we don't really need to keep values in `a` or `b` once they've been handled; this special kind of array only holds a value only as long as its needed. So these arrays don't strictly grow in memory usage over time, an important characteristic of lazy data structures and operations. In fact, it's less like an array and more like a buffer.

A normal array is eager in that it holds all of its values right now. A "lazy array" is an array where the values will come in over time.

Since we won't necessarily know when a new value has arrived in `a`, another key thing we need is to be able to listen to `b` to be notified when new values are made available. We could imagine a listener like this:

```js
b.listen( function onValue(v){
	console.log( v );
} );
```

`b` is *reactive* in that it's set up to *react* to values as they come into `a`. There's an FP operation `map(..)` that describes how each value transfers from the origin `a` to the target `b`. Each discrete mapping operation is exactly how we modeled single-value operations with normal synchronous FP, but here we're spreading out the sourcing of values over time.

**Note:** The term most commonly applied to these concepts is Functional Reactive Programming (FRP). I'm deliberately avoiding that term because there's some debate as to whether FP + Reactive genuinely constitutes FRP. We're not going to fully dive into all the implications of FRP here, so I'll just keep calling it reactive FP. Alternately, you could call it evented-FP if that feels less confusing.

We can think of `a` as producing values and `b` as consuming them. So for readability, let's reorganize this snippet to separate the concerns into *producer* and *consumer* roles:

```js
// producer:

var a = new LazyArray();

setInterval( function everySecond(){
	a.push( Math.random() );
}, 1000 );


// **************************
// consumer:

var b = a.map( function double(v){
	return v * 2;
} );

b.listen( function onValue(v){
	console.log( v );
} );
```

`a` is the producer, which acts essentially like a stream of values. We can think of each value arriving in `a` as an *event*. The `map(..)` operation then triggers a corresponding event on `b`, which we `listen(..)` to so we can consume the new value.

The reason we separate the *producer* and *consumer* concerns is so that different parts of our application can be responsible for each concern. This code organization can drastically improve both code readability and maintenance.

### Declarative Time

We're being very careful about how we introduce time into the discussion. Specifically, just as promises abstract time away from our concern for a single asynchronous operation, reactive FP abstracts (separates) time away from a series of values/operations.

From the perspective of `a` (the producer), the only evident time  concern is our manual `setInterval(..)` loop. But that's only for demonstration purposes.

Imagine `a` could actually be attached to some other event source, like the user's mouse clicks or keystrokes, websocket messages from a server, etc. In that scenario, `a` doesn't actually have to concern itself with time. It's merely a time-independent conduit for values, whenever they are ready.

From the perspective of `b` (the consumer), we do not know or care when/where the values in `a` come from. As a matter of fact, all the values could already be present. All we care about is that we want those values, whenever they are ready. Again, this is a time-independent (aka lazy) modeling of the `map(..)` transformation operation.

The *time* relationship between `a` and `b` is declarative, not imperative.

The value of organizing such operations-over-time this way may not feel particularly effective yet. Let's compare to how this same sort of functionality could have be expressed imperatively:

```js
// producer:

var a = {
	onValue(v){
		b.onValue( v );
	}
};

setInterval( function everySecond(){
	a.onValue( Math.random() );
}, 1000 );


// **************************
// consumer:

var b = {
	map(v){
		return v * 2;
	},
	onValue(v){
		v = this.map( v );
		console.log( v );
	}
};
```

It may seem rather subtle, but there's a important difference between this more-imperative version of the code and the previous more-declarative version, aside from just `b.onValue(..)` needing to call `this.map(..)` itself. In the former snippet, `b` pulls from `a`, but in the latter snippet, `a` pushes to `b`. In other words, compare `b = a.map(..)` to `b.onValue(v)`.

In the latter imperative snippet, it's not clear (readability wise) from the consumer's perspective where the `v` values are coming from. Moreover, the imperative hard coding of `b.onValue(..)` in the mix of producer `a`'s logic is a bit of a violation of separation-of-concerns. That can make it harder to reason about producer and consumer independently.

By contrast, in the former snippet, `b = a.map(..)` declares that `b`'s values are seeded from `a`, and treats `a` as abstract event stream data source that we don't have to concern ourselves with at that moment. We *declare* that any value that comes from `a` into `b` will go through the `map(..)` operation as specified.

### More Than Map

For convenience, we've illustrated this notion of pairing `a` and `b` together over time via a one-to-one `map(..)`ing. But many of our other FP operations could be modeled over time as well.

Consider:

```js
var b = a.filter( function isOdd(v) {
	return v % 2 == 1;
} );

b.listen( function onlyOdds(v){
	console.log( "Odd:", v );
} );
```

Here, a value from `a` only comes into `b` if it passes the `isOdd(..)` predicate.

Even `reduce(..)` can be modeled over time:

```js
var b = a.reduce( function sum(total,v){
	return total + v;
} );

b.listen( function runningTotal(v){
	console.log( "New current total:", v );
} );
```

Since we don't specify an `initialValue` to the `reduce(..)` call, neither the `sum(..)` reducer nor the `runningTotal(..)` event callback will be invoked until at least two values have come through from `a`.

This snippet implies that the reduction has a *memory* of sorts, in that each time a future value comes in, the `sum(..)` reducer will be invoked with whatever the previous `total` was as well as the new next value `v`.

Other FP operations extended over time could even involve an internal buffer, like for example `unique(..)` keeping track of every value it's seen so far.

### Observables

Hopefully by now you can see the importance of a reactive, evented, array-like data structure like the fictional `LazyArray` we've conjured. The good news is, this kind of data structure already exists, and it's called an observable.

**Note:** Just to set some expectation: the following discussion is only a brief intro to the world of observables. This is a far more in-depth topic than we have space to fully explore. But if you've understood functional-light programming in this text, and now understood how asynchronous-time can be modeled via FP principles, observables should follow very naturally for your continued learning.

Observables have been implemented by a variety of userland libraries, most notably RxJS and Most. At the time of this writing, there's an in-progress proposal to add observables directly to JS, just like promises. For the sake of demonstration, we'll use RxJS-flavored Observables for these next examples.

Here's our earlier reactive example, expressed with Observables instead of `LazyArray`:

```js
// producer:

var a = new Rx.Subject();

setInterval( function everySecond(){
	a.next( Math.random() );
}, 1000 );


// **************************
// consumer:

var b = a.map( function double(v){
	return v * 2;
} );

b.subscribe( function onValue(v){
	console.log( v );
} );
```

In the RxJS universe, an Observer subscribes to an Observable. If you combine the functionality of an Observer and an Observable, you get a Subject. So, to keep our snippet simpler, we construct `a` as a Subject, so that we can call `next(..)` on it to push values (events) into its stream.

If we want to keep the Observer and Observable separate:

```js
// producer:

var a = Rx.Observable.create( function onObserve(observer){
	setInterval( function everySecond(){
		observer.next( Math.random() );
	}, 1000 );
} );
```

In this snippet, `a` is the Observable, and unsurprisingly, the separate observer is called `observer`; it's able to "observe" some events (like our `setInterval(..)` loop); we use its `next(..)` method to send events to the `a` observable stream.

In addition to `map(..)`, RxJS defines well over a hundred operators that are invoked lazily as each new value comes in. Just like with arrays, each operator on an Observable returns a new Observable, meaning they are chainable. If an invocation of operator function determines a value should be passed along from the input Observable, it will be fired on the output Observable; otherwise it's discarded.

Example of a declarative observable chain:

```js
var b =
	a
	.filter( v => v % 2 == 1 )		// only odd numbers
	.distinctUntilChanged()			// only consecutive-distinct
	.throttle( 100 )				// slow it down a bit
	.map( v = v * 2 );				// double them

b.subscribe( function onValue(v){
	console.log( "Next:", v );
} );
```

**Note:** It's not necessary to assign the observable to `b` and then call `b.subscribe(..)` separately from the chain; that's only done to reinforce that each operator returns a new observable from the previous one. Often, the `subscribe(..)` call is just the final method in the chain.

## Summary

This book has detailed a wide variety of FP operations that take a single value (or an immediate list of values) and transform them into another value/values.

For operations that will be proceed over time, all of these foundational FP principles can be applied time-independently. Exactly like promises model single future values, we can model eager lists of values instead as lazy observable (event) streams of values that may come in one-at-a-time.

A `map(..)` on an array runs its mapping function once for each value currently in the array, putting all the mapped values in the outcome array. A `map(..)` on an observable runs its mapping function once for each value, whenever it comes in, and pushes all the mapped values to the output observable.

In other words, if an array is an eager data structure for FP operations, an observable is its lazy over-time counterpart.
