# Functional-Light JavaScript
# Chapter 11: Putting It All Together

现在，你拥有了为了理解轻量函数式 JavaScript 所需的一切。再没有新的概念要介绍了。

在这最后的一章中，我们的目标是凝聚这些概念。我们将看到将这本书中许多主题融合在一起的代码 —— 应用我们学到的东西。最重要的是，这篇代码示例是为了展示 “轻量函数式” 应用到 JavaScript 上的方式 —— 也就是，平衡以及教条之上的实用主义。

你将会想要广泛地亲自实践这些技术。消化理解这一章对于你将 FP 的概念应用于真实世界的代码至关重要。

## Setup

让我们建造一个简单的证券报价机控件。

**注意：** 为了便于引用，这个示例的全部代码位于 `ch11-code/` 子目录中 —— 参见这本书的 GitHub 代码库 (https://github.com/getify/Functional-Light-JS)。另外，这个示例需要选用一些我们在这本书中讨论过的 FP 帮助函数，它们包含在 `ch11-code/fp-helpers.js` 中。本章中我们仅将注意力集中在与我们的讨论有关的部分代码中。

首先，让我谈谈这个控件的至标代码，这样我们才有地方来展示信息。我们从 `ch11-code/index.html` 文件中的一个空 `<ul ..>` 元素开始，当运行的时候，DOM 将会被填充为：

```html
<ul id="stock-ticker">
	<li class="stock" data-stock-id="AAPL">
		<span class="stock-name">AAPL</span>
		<span class="stock-price">$121.95</span>
		<span class="stock-change">+0.01</span>
	</li>
	<li class="stock" data-stock-id="MSFT">
		<span class="stock-name">MSFT</span>
		<span class="stock-price">$65.78</span>
		<span class="stock-change">+1.51</span>
	</li>
	<li class="stock" data-stock-id="GOOG">
		<span class="stock-name">GOOG</span>
		<span class="stock-price">$821.31</span>
		<span class="stock-change">-8.84</span>
	</li>
</ul>
```

在我们前进之前，让我提醒你一下：与 DOM 的交互是一种 I/O，而这意味着副作用。我们不能消灭这些副作用，但可以限制并控制它们。我们要确实有意地将我们的应用程序处理 DOM 的表面积控制在最小。我们已经在第五章中学习过这些技术了。

概括一下我们的控件的功能：这段代码将会在每次 “收到” 新证券事件时添加一个 `<li ..>` 元素，并在证券更新事件到来时更新它的价格。

在第十一章的示例代码，`ch11-code/mock-server.js` 中，我们设立了某种定时器，它随机地向一个简单事件发生器推送虚构的证券数据，来模拟我们正在从一个服务器接受证券信息。我们暴露了一个 `connectToServer()` 函数假装这样做，但实际上只是一个虚构的事件发生器实例。

**注意：** 这个文件中都是虚构/模拟的行为，所以我没有花费太多的力气来使它支持 FP。我不建议你花太多的事件来关心这个文件中的代码。如果你写了一个真的服务器 —— 对于有雄心的读者来说是一个非常有趣的额外练习！ —— 那么显然你将会对这段代码进行它应得的 FP 思考。

在 `ch11-code/stock-ticker-events.js` 中，我们（通过 RxJS）建立了某种连接到事件发生器对象的 observable。我们调用 `connectToServer()` 来得到这个事件发生器，然后监听名为 `"stock"`（向我们的标价机添加新证券）和 `"stock-update"`（更新证券的价格以及涨跌额度）的事件。最后，我们为这些 observable 的输入数据定义变性规则，按需要格式化数据。

在 `ch11-code/stock-ticker.js` 中，我们在 `stockTickerUI` 对象上将 UI（DOM 副作用）的行为定义为方法。我们还定义了各种帮助函数，包括 `getElemAttr(..)`、`stripPrefix(..)`、和其他一些。最后，我们 `subscribe(..)` 两个向我们提供格式化数据的 observable 来渲染 DOM。

## Stock Events

让我们看看 `ch11-code/stock-ticker-events.js` 中的代码。我们将从一些基本的帮助函数开始：

```js
function addStockName(stock) {
	return setProp( "name", stock, stock.id );
}
function formatSign(val) {
	if (Number(val) > 0) {
		return `+${val}`;
	}
	return val;
}
function formatCurrency(val) {
	return `$${val}`;
}
function transformObservable(mapperFn,obsv){
	return obsv.map( mapperFn );
}
```

这些纯函数理解起来应该相当直接了当。回忆一下，第四章中的 `setProp(..)` 在设置新属性之前实际上克隆了对象。这行使了我们在第六章中看到的原则：通过将值视为不可变的 —— 即使它们不是 —— 来避免副作用。

`addStockName(..)` 用来向一个政权消息对象添加 `name` 属性，值与它的 `id` 相等。`name` 的值稍后用作控件中可见的证券名称。

在 `transformObservable(..)` 上有一个微妙的注意点：因为在一个 observable 上进行 `map(..)` 返回一个新的 observable，所以它看起来是纯粹的。但从技术上讲，在它的底层，`obsv` 的内部状态被改变为连接到 `map(..)` 返回的新 observable。这种副作用没什么大不了的，而且不会损害我们代码的可读性，但是无论副作用在什么地方你都能发现它们非常重要，而不是在你遇到 bug 是被它们吓一跳。

当一个来自于 “服务器” 的证券信息被接受到时，它看起来就像：

```js
{ id: "AAPL", price: 121.7, change: 0.01 }
```

在展示在 DOM 上之前，`price` 需要用 `formatCurrency(..)` 格式化（`"$121.70"`），而且 `change` 需要用 `formatChange(..)` 格式化 （`"+0.01"`）。但我们不想改变消息对象，所以我们需要一个帮助函数来格式化数字并给我们一个新的证券对象；

```js
function formatStockNumbers(stock) {
	var updateTuples = [
		[ "price", formatPrice( stock.price ) ],
		[ "change", formatChange( stock.change ) ]
	];

	return reduce( function formatter(stock,[propName,val]){
		return setProp( propName, stock, val );
	} )
	( stock )
	( updateTuples );
}
```

我们创建了 `updateTuples` 数组来分别为 `price` 和 `change` 保持两个属性名和格式化后的值的元组（就是数组）。我们在这个数组上 `reduce(..)`（参见第八章），将 `stock` 对象作为 `initialValue`。我们将元组分解为 `propName` 和 `val`，之后返回 `setProp(..)` 调用，它继而返回一个带有设定好属性的新的克隆对象。

现在让我们再定义一些帮助函数：

```js
var formatDecimal = unboundMethod( "toFixed" )( 2 );
var formatPrice = pipe( formatDecimal, formatCurrency );
var formatChange = pipe( formatDecimal, formatSign );
var processNewStock = pipe( addStockName, formatStockNumbers );
```

函数 `formatDecimal(..)` 接收一个数字（比如 `2.1`）并调用它的 `toFixed( 2 )` 方法。我们使用第八章的 `unboundMethod(..)` 来建立一个独立的推迟绑定的方法。

`formatPrice(..)`、`formatChange(..)`、和 `processNewStock(..)` 都使用 `pipe(..)` 将一些操作从左至右地组合起来（参见第四章）。

为了从我们的事件发生器中创建 observable（参见第十章），我们需要一个帮助函数，它是 RxJS 中 `Rx.Observable.fromEvent(..)` 的一个柯里化（参见第三章）独立函数：

```js
var makeObservableFromEvent = curry( Rx.Observable.fromEvent, 2 )( server );
```

这个函数被指定为监听 `server`（事件发生器），而且在等待一个事件名称字符串来生成它的 observable。现在我们准备好了为两个事件创建 observer 所需的所有配件，可以对这些 observer 进行映射变形来格式化输入数据：

```js
var observableMapperFns = [ processNewStock, formatStockNumbers ];

var [ newStocks, stockUpdates ] = pipe(
	map( makeObservableFromEvent ),
	curry( zip )( observableMapperFns ),
	map( spreadArgs( transformObservable ) )
)
( [ "stock", "stock-update" ] );
```

我们从事件名称的数组开始 （`["stock","stock-update"]`），然后将这个列表 `map(..)`（参见第八章）为一个包含两个 observable 的列表，然后将这个列表 `zip(..)`（参见第八章）为一个 observable 映射函数的列表；这个映射生成了一个元组的列表，就像 `[ observable, mapperFn ]`。最后，我们使用 `transformObservable(..)` 来 `map(..)` 这个元组的列表，使用 `spreadArgs(..)`（参见第三章）来把每个元组分散为独立的参数。

结果就是一个格式化后的 observable 列表，我们通过数组解构将它们分别赋值给 `newStocks` 和 `stockUpdates`。

就是这样；这就是我们如何使用轻量 FP 方式建立证券报价事件 observable！我们将在 `ch11-code/stock-ticker.js` 中订阅这两个 observable。

退后一步并反思一下我们这里对 FP 原则的使用。它合理吗？你能看出我们是如何应用这本书前几章中讲解的各种概念的吗？你能想出完成这些任务的其他方法吗？

更重要的是，你如何用指令式方式完成它，而且你对这两种方式大体上比较起来有什么看法？试着练习一下。使用你熟知的指令式方式编写它的等价物。如果你像我一样，指令式形式将依然使人感觉更自然。

在继续之前你需要 *学会* 的是，你 *也* 可以理解并推理我们刚刚展示的 FP 风格。考虑一下每一个函数和代码段的形状（输入与输出）。你看出它们是如何联系在一起的吗？

在你适应这些东西之前，要不断练习。

## Stock Ticker UI

如果你对前一节中的 FP 感到相当舒适，那么你就准备好深入 `ch11-code/stock-ticker.js` 了。它相当复杂，所以我们将花一些时间来看看它整体的每一部分。

让我们先定义一些可以辅助我们 DOM 操作任务的帮助函数：

```js
function isTextNode(node) {
	return node && node.nodeType == 3;
}
function getElemAttr(elem,prop) {
	return elem.getAttribute( prop );
}
function setElemAttr(elem,prop,val) {
	// !!SIDE EFFECTS!!
	return elem.setAttribute( prop, val );
}
function matchingStockId(id) {
	return function isStock(node){
		return getStockId( node ) == id;
	};
}
function isStockInfoChildElem(elem) {
	return /\bstock-/i.test( getClassName( elem ) );
}
function appendDOMChild(parentNode,childNode) {
	// !!SIDE EFFECTS!!
	parentNode.appendChild( childNode );
	return parentNode;
}
function setDOMContent(elem,html) {
	// !!SIDE EFFECTS!!
	elem.innerHTML = html;
	return elem;
}

var createElement = document.createElement.bind( document );

var getElemAttrByName = curry( reverseArgs( getElemAttr ), 2 );
var getStockId = getElemAttrByName( "data-stock-id" );
var getClassName = getElemAttrByName( "class" );
```

这些东西应当几乎都是自解释的。我为 `getElemAttrByName(..)` 使用了 `curry(reverseArgs( .. ))`（参见第三章）而非 `partialRight(..)`，仅仅是为了这种特定的情况挤出好一些的性能。

注意我明确指出了改变 DOM 元素状态的副作用。我们不能很容易地克隆一个 DOM 对象并替换它，所以在这里我们安于一些改变既存 DOM 元素的副作用。至少，如果我们在 DOM 渲染上发生了 bug，我们可以很容易地检索这些代码注释来缩小可疑代码的范围。

`matchingStockId(..)` 展示了闭包（参见第二章）的用法（之一！）—— 创建一个即使稍后在一个不同作用域中运行时也能记住变量 `id` 的内部函数（`isStock(..)`）。

这是一些其他的杂项帮助函数：

```js
function stripPrefix(prefixRegex) {
	return function mapperFn(val) {
		return val.replace( prefixRegex, "" );
	};
}
function listify(listOrItem) {
	if (!Array.isArray( listOrItem )) {
		return [ listOrItem ];
	}
	return listOrItem;
}
```

让我们定义一个可以帮我们取得一个 DOM 元素子节点的帮助函数：

```js
var getDOMChildren = pipe(
	listify,
	flatMap(
		pipe(
			curry( prop )( "childNodes" ),
			Array.from
		)
	)
);
```

首先，我们使用 `listify(..)` 来确保我们有一个元素的列表（即便它只有一个元素）。回忆一下第八章的 `flatMap(..)`，它映射一个列表并将一个列表的列表扁平化为一个浅层列表。

我们这里的映射函数将一个元素映射为它的 `childNodes` 列表，然后我们使用 `Array.from(..)` 将它变成真正的数组（而不是一个实时的 NodeList）。这两个函数（通过 `pipe(..)`）被组合为一个单独的映射函数，这就是融合（参见第八章）。

现在，让我们使用这个 `getDOMChildren(..)` 帮助函数来定义从控件中取得制定 DOM 元素的工具：

```js
function getStockElem(tickerElem,stockId) {
	return pipe(
		getDOMChildren,
		filterOut( isTextNode ),
		filterIn( matchingStockId( stockId ) )
	)
	( tickerElem );
}
function getStockInfoChildElems(stockElem) {
	return pipe(
		getDOMChildren,
		filterOut( isTextNode ),
		filterIn( isStockInfoChildElem )
	)
	( stockElem );
}
```

`getStockElem(..)` 从我们控件的 `tickerElem` DOM 元素开始，取得它的子元素，然后过滤它来确保我们得到匹配指定证券标识符的元素。`getStockInfoChildElems(..)` 做的几乎是相同的事情，除了它是从一个证券元素开始，而且使用不同的过滤器来过滤。

两个工具都滤除了文本节点（因为它们与真正 DOM 节点的工作方式不同），而且两个工具都返回一个 DOM 元素的数组，即使它仅含有一个元素。

### Main API

We'll use a `stockTickerUI` object to organize our three main UI manipulation methods, like this:

我们将使用一个 `stockTickerUI` 对象来组织我们的三个主 UI 操作方法，就像这样：

```js
var stockTickerUI = {

	updateStockElems(stockInfoChildElemList,data) {
		// ..
	},

	updateStock(tickerElem,data) {
		// ..
	},

	addStock(tickerElem,data) {
		// ..
	}
};
```

Let's first examine `updateStock(..)`, as its the simplest of the three:

让我们首先检视一下 `updateStock(..)`，因为它是三个中最简单的：

```js
var stockTickerUI = {

	// ..

	updateStock(tickerElem,data) {
		var getStockElemFromId = curry( getStockElem )( tickerElem );
		var stockInfoChildElemList = pipe(
			getStockElemFromId,
			getStockInfoChildElems
		)
		( data.id );

		return stockTickerUI.updateStockElems(
			stockInfoChildElemList,
			data
		);
	},

	// ..

};
```

Currying the earlier helper `getStockElem(..)` with `tickerElem` gives us `getStockElemFromId(..)`, which will receive `data.id`. That `<li>` element (actually, a list of that element) is passed to `getStockInfoChildElems(..)`, giving us three child `<span>` elements for the stock display info, which we call `stockInfoChildElemList`. We pass this list and the stock `data` message object along to `stockTickerUI.updateStockElems(..)` for actually updating those `<span>`s with the updated data.

使用 `tickerElem` 柯里化早先的帮助函数 `getStockElem(..)` 给了我们 `getStockElemFromId(..)`，它将接收 `data.id`。这个 `<li>` 元素（实际上，是这个元素的列表）被传递给 `getStockInfoChildElems(..)`，给了我们三个 `<span>` 子元素来展示证券信息，我们称之为 `stockInfoChildElemList`。我们将这个列表与证券 `data` 消息对象一起传递给 `stockTickerUI.updateStockElems(..)` 来真正地使用更新过的数据更新那些 `<span>`。

Now let's look at `stockTickerUI.updateStockElems(..)`:

现在让我们看看 `stockTickerUI.updateStockElems(..)`：

```js
var stockTickerUI = {

	updateStockElems(stockInfoChildElemList,data) {
		var getDataVal = curry( reverseArgs( prop ), 2 )( data );
		var extractInfoChildElemVal = pipe(
			getClassName,
			stripPrefix( /\bstock-/i ),
			getDataVal
		);
		var orderedDataVals =
			map( extractInfoChildElemVal )( stockInfoChildElemList );
		var elemsValsTuples =
			filterOut( function updateValueMissing([infoChildElem,val]){
				return val === undefined;
			} )
			( zip( stockInfoChildElemList, orderedDataVals ) );

		// !!SIDE EFFECTS!!
		compose( each, spreadArgs )
		( setDOMContent )
		( elemsValsTuples );
	},

	// ..

};
```

That's a bit to take in, I know. But we'll break it down statement by statement.

`getDataVal(..)` is bound to the `data` message object, having been curried after argument-reversing, so it's waiting for a property name to extract from `data`.

Next, let's look at `extractInfoChildElem`:

```js
var extractInfoChildElemVal = pipe(
	getClassName,
	stripPrefix( /\bstock-/i ),
	getDataVal
);
```

This function takes a DOM element, gets it DOM class, strips the `"stock-"` prefix from it, then uses that value (`"name"`, `"price"`, or `"change"`) to extract a value of that same name from `data` via `getDataVal(..)`. On the surface, that may seem like a slightly strange action.

The purpose, though, is to extract the values from `data` in the same order as the `<span>` elements (in `stockInfoChildElemList`). We accomplish this by using `extractInfoChildElem(..)` as the mapping function over that list, calling the resulting list `orderedDataVals`.

Next, we're going to zip our list of `<span>`s with this list of values, producing tuples:

```js
zip( stockInfoChildElemList, orderedDataVals )
```

An interesting wrinkle that wasn't at all obvious up to this point is that because of how we defined the observables transforms, new-stock message objects will have a `name` property in `data` to match up with the `<span class="stock-name">` element, but `name` will be absent on stock-update message objects.

As a general notion, if the data message object doesn't have a property, we shouldn't update that corresponding DOM element. So, we need to `filterOut(..)` any tuples where the value (in this case, in the second position) is `undefined`:

```js
var elemsValsTuples =
	filterOut( function updateValueMissing([infoChildElem,val]){
		return val === undefined;
	} )
	( zip( stockInfoChildElemList, orderedDataVals ) );
```

The result after this filtering is a list of tuples (like `[ <span>, ".." ]`) ready for DOM content updating, which we assign to `elemsValsTuples`.

**Note:** Since the `updateValueMissing(..)` predicate is specified inline here, we're in control of its signature. Instead of using `spreadArgs(..)` to adapt it to spread out a single array argument as two individual named parameters, we use parameter array-destructuring in the function declaration (`function updateValueMissing([infoChildElem,val]){ ..`); see Chapter 2 for more information.

Finally, we need to update the DOM content of our `<span>` elements:

```js
// !!SIDE EFFECTS!!
compose( each, spreadArgs )( setDOMContent )
( elemsValsTuples );
```

We iterate this `elemsValsTuples` list with `each(..)` (see `forEach(..)` discussion in Chapter 8).

Instead of using `pipe(..)` as elsewhere, this composition uses `compose(..)` (see Chapter 4) to pass `setDomContent(..)` into `spreadArgs(..)`, and then that is passed as the iterator-function to `each(..)`. Each tuple is spread out as the arguments to `setDOMContent(..)`, which then updates the DOM element accordingly.

That's two of the main UI methods down, one to go: `addStock(..)`. Let's define it in its entirety, then we'll examine it step by step as before:

```js
var stockTickerUI = {

	// ..

	addStock(tickerElem,data) {
		var [stockElem, ...infoChildElems] = map(
			createElement
		)
		( [ "li", "span", "span", "span" ] );
		var attrValTuples = [
			[ ["class","stock"], ["data-stock-id",data.id] ],
			[ ["class","stock-name"] ],
			[ ["class","stock-price"] ],
			[ ["class","stock-change"] ]
		];
		var elemsAttrsTuples =
			zip( [stockElem, ...infoChildElems], attrValTuples );

		// !!SIDE EFFECTS!!
		each( function setElemAttrs([elem,attrValTupleList]){
			each(
				spreadArgs( partial( setElemAttr, elem ) )
			)
			( attrValTupleList );
		} )
		( elemsAttrsTuples );

		// !!SIDE EFFECTS!!
		stockTickerUI.updateStockElems( infoChildElems, data );
		reduce( appendDOMChild )( stockElem )( infoChildElems );
		tickerElem.appendChild( stockElem );
	}

};
```

This UI method needs to create the bare DOM structure for a new stock element, and then use `stockTickerUI.updateStockElems(..)` to update its content as already described.

First:

```js
var [stockElem, ...infoChildElems] = map(
	createElement
)
( [ "li", "span", "span", "span" ] );
```

We create the parent `<li>` and the three children `<span>` elements, assigning them respectively to `stockElem` and the `infoChildElems` list.

To initialize these elements with the appropriate DOM attributes, we create a list of lists-of-tuples. Each item in the main list represents the four DOM elements, in order. Each tuple inside each sub-list represents an attribute-value pair to be set on the corresponding DOM element:

```js
var attrValTuples = [
	[ ["class","stock"], ["data-stock-id",data.id] ],
	[ ["class","stock-name"] ],
	[ ["class","stock-price"] ],
	[ ["class","stock-change"] ]
];
```

We now want to `zip(..)` a list of the four DOM elements with this `attrValTuples` list:

```js
var elemsAttrsTuples =
	zip( [stockElem, ...infoChildElems], attrValTuples );
```

The structure of this list would look like:

```
[
	[ <li>, [ ["class","stock"], ["data-stock-id",data.id] ] ],
	[ <span>, [ ["class","stock-name"] ] ],
	..
]
```

If we wanted to imperatively process this kind of data structure to assign the attribute-value tuples into each DOM element, we'd probably use nested `for`-loops. Our FP approach will be similar, but with nested `each(..)` iterations:

```js
// !!SIDE EFFECTS!!
each( function setElemAttrs([elem,attrValTupleList]){
	each(
		spreadArgs( partial( setElemAttr, elem ) )
	)
	( attrValTupleList );
} )
( elemsAttrsTuples );
```

The outer `each(..)` iterates the list of tuples, with each `elem` and its associated `attrValTupleList` spread out as named parameters to `setElemAttrs(..)` via parameter array-destructuring as explained earlier.

Inside this outer iteration "loop", the sub-list of attribute-value tuples is iterated with an inner `each(..)`. The inner iterator-function is an arguments-spread (of each attribute-value tuple) for the partial-application of `setElemAttr(..)` with `elem` as its first argument.

At this point, we have a list of `<span>` elements, each filled out with attributes, but no `innerHTML` content. We set the `data` into the child `<span>` elements with `stockTickerUI.updateStockElems(..)`, the same as for a stock-update event.

Now, we need to append these `<span>`s to the parent `<li>`, and we do that with a `reduce(..)` (see Chapter 8):

```js
reduce( appendDOMChild )( stockElem )( infoChildElems );
```

Finally, a plain ol' DOM mutation side effect to append the new stock element to the widget's DOM:

```js
tickerElem.appendChild( stockElem );
```

Phew! Did you follow all that? I recommend you go back and re-read that discussion a few times and practice with the code, before moving on.

### Subscribing To Observables

Our last major task is to subscribe to the observables defined in `ch11-code/stock-ticker-events.js`, attaching these subscriptions to the appropriate main UI methods (`addStock(..)` and `updateStock(..)`).

First, we notice that those methods each expect `tickerElem` as first parameter. Let's make a list (`stockTickerUIMethodsWithDOMContext`) that encapsulates the ticker widget's DOM element with each of these two methods, via partial application (aka, closure; see Chapter 2):

```js
var ticker = document.getElementById( "stock-ticker" );

var stockTickerUIMethodsWithDOMContext = map(
	curry( reverseArgs( partial ), 2 )( ticker )
)
( [ stockTickerUI.addStock, stockTickerUI.updateStock ] );
```

`reverseArgs( partial )` is the same performance-optimized `partialRight(..)` substitute from earlier. But this time, `partial(..)` is the intended mapper function. To accomplish that, we need to `curry(..)` it so we can pre-specify the second argument `ticker` ahead of time; when each UI method is then mapped, it partially applies that function with `ticker`. The two partially-applied functions in the resulting array are now suitable for observable subscription.

Though we're using closure to preserve the `ticker` state with these two functions, in Chapter 7 we saw that we could have "kept" this `ticker` value as a property on an object, perhaps via `this`-binding each function to `stockTickerUI`. Since `this` is an implicit input (see Chapter 2) and that's generally not as preferable, I choose the closure form over the object form.

To subscribe to the observables, let's make an unbound-method helper:

```js
var subscribeToObservable =
	pipe( uncurry, spreadArgs )( unboundMethod( "subscribe" ) );
```

`unboundMethod("subscribe")` is automatically curried, so we `uncurry(..)` it (see Chapter 3), then adapt it with `spreadArgs(..)` (again, see Chapter 3) so it'll spread out a single tuple array as its two arguments.

Now, we just need a list of the observables, so we can `zip(..)` that with the list of context-encapsulated UI methods. That list of tuples can then each be subscribed with the `subscribeToObservable(..)` helper we just defined in the previous snippet:

```js
var stockTickerObservables = [ newStocks, stockUpdates ];

// !!SIDE EFFECTS!!
each( subscribeToObservable )
( zip( stockTickerUIMethodsWithDOMContext, stockTickerObservables ) );
```

Since we're technically mutating the state of those observables to subscribe to them, and moreover since we're using `each(..)` -- pretty much always associated with side effects! -- we call that fact out with our code comment.

That's it! Spend the same time reviewing and comparing this code to its imperative alternatives as we did in with the stock ticker events discussion earlier. Really, take your time. I know it's been a long book, but your whole reading comes down to being able to digest and understand this kind of code.

How do you feel now about using FP in a balanced way in your JavaScript? Keep practicing just like we did here!

## Summary

The example code we discussed in this chapter should be viewed in its entirety, not just in the broken out snippets as presented in this chapter. Stop right now and go read through the full files, if you haven't already. Make sure you understand them in full context.

This example code is not meant to be prescriptive of exactly how you should write your code. It's meant to be more descriptive of how to think about and begin approaching such tasks with FP-light techniques. It's meant to draw as many correlations between the different concepts of this book as possible. It's meant to explore FP in the context of more "real" code than we typically afford for a single snippet.

I am quite sure that as I learn FP better on my own journey, I will continue to improve how I would write this example code. What you see now is just a snapshot on my curve. I hope it will just be such for you, as well.

As we draw the main text of this book to a close, I want to remind you of this readability curve that I shared back in Chapter 1:

<p align="center">
	<img src="fig17.png" width="600">
</p>

It's so important that you internalize the truth of that graph and set realistic expectations for yourself on this journey to learn and apply FP principles to your JavaScript. You've made it this far, and that's quite an accomplishment.

But don't stop when you dip towards that trough of despair and disenchantment. What's waiting on the other side is a way of thinking about and communicating with your code that's more readable, understandable, verifable, and ultimately, more reliable.

I can't think of any more noble goal for us as developers to strive towards. Thanks for sharing in my journey to learn FP principles in JavaScript. I hope your's is as rich and hopeful as mine!
